<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #chart {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="chart"></div>
    <script src="https://unpkg.com/lightweight-charts@3.7.0/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        let chart = null;
        let series = null;
        let pendingData = null;

        console.log('mini-chart.html loaded');

        function tryInit() {
            const container = document.getElementById('chart');
            console.log('tryInit: LightweightCharts=' + (typeof LightweightCharts) + ', clientWidth=' + container.clientWidth + ', chart=' + !!chart);
            if (typeof LightweightCharts === 'undefined' || !container.clientWidth || chart) {
                return false;
            }

            chart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: container.clientHeight,
                layout: { background: { color: 'transparent' }, textColor: 'transparent' },
                grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                rightPriceScale: { visible: false },
                timeScale: { visible: false },
                crosshair: { vertLine: { visible: false }, horzLine: { visible: false } },
                handleScroll: false,
                handleScale: false,
            });

            series = chart.addAreaSeries({
                lineWidth: 2,
                priceLineVisible: false,
                lastValueVisible: false,
                crosshairMarkerVisible: false,
            });

            if (pendingData) {
                window.updateData(pendingData);
                pendingData = null;
            }
            return true;
        }

        window.updateData = function (payload) {
            console.log('updateData called with payload length=' + (typeof payload === 'string' ? JSON.parse(payload).length : payload.length));
            if (!chart) {
                console.log('updateData: no chart yet, storing pending data');
                pendingData = payload;
                tryInit();
                return;
            }

            try {
                const rawData = (typeof payload === 'string') ? JSON.parse(payload) : payload;
                const mapped = rawData.map((v, i) => ({
                    time: i,
                    value: typeof v === 'number' ? v : (v.close || v.price || 0)
                }));

                if (mapped.length === 0) return;

                const isBullish = mapped[mapped.length - 1].value >= mapped[0].value;
                const color = isBullish ? '#10b981' : '#f43f5e';
                const topColor = isBullish ? 'rgba(16, 185, 129, 0.4)' : 'rgba(244, 63, 94, 0.4)';

                series.applyOptions({
                    lineColor: color,
                    topColor: topColor,
                    bottomColor: 'rgba(0, 0, 0, 0)',
                });

                console.log('updateData: setting data with ' + mapped.length + ' points');
                series.setData(mapped);
                chart.timeScale().fitContent();
            } catch (e) {
                console.error('JS_CHART_ERROR:', e);
            }
        };

        const initInterval = setInterval(() => {
            if (tryInit()) clearInterval(initInterval);
        }, 50);

        const ro = new ResizeObserver(() => {
            if (chart) {
                const container = document.getElementById('chart');
                chart.resize(container.clientWidth, container.clientHeight);
            } else {
                tryInit();
            }
        });
        ro.observe(document.body);
    </script>
</body>

</html>